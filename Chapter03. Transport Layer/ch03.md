## 3.1 Introduction and Transport-Layer Services

A transport-layer protocol provides for logical communication (as if the hosts running the processes were directly connected) between application processes running on different hosts. 

<p align="center">
<img width="400" alt="Screenshot 2024-12-09 at 1 11 32 AM" src="https://github.com/user-attachments/assets/4f9cae45-ef14-4d42-b113-1f215732543b">
</p>


- Application processes use the logical communication provided by the transport layer to send messages to each other, free from the worry of the details of the physical infrastructure used. 

- Transport-layer protocols are implemented in the **end systems but not in network routers**
  
-  On the sending side, the transport layer converts the application messages into transport-layer packets,(transport-layer segments)   by breaking them into smaller chunks and adding a transport-layer header to each chunk. The transport-layer then passes the segment to the network-layer packet at the sending end-system.
  
-  On the receiving side, the network layer extracts the transport-layer segment from the datagram and passes the segment up to the transport-layer which then processes the received segment, 
making the data in the segment available to the received application.

<p align="center">
<img width="550" alt="Screenshot 2024-12-09 at 1 11 32 AM" src= "https://github.com/user-attachments/assets/1f0eaa6b-1da8-4f73-84f8-b55653a1641c">
</p>

### 3.1.1 Relationship Between Transport and Network Layers
A transport-layer protocol provides for logical communication between application processes running on different hosts. relies on, enhances, network layer services

A network-layer protocol provides logical communication between hosts.

![Network](

### 3.1.2 Overview of the Transport Layer in the Internet
- The Protocol Data Unit (PDU) at the transport layer is called a segment (for TCP) or a datagram (for UDP).
- A TCP/IP network (such as the Internet) makes two distinct transport-layer protocols available to the application layer:

**Comparison of TCP and UDP**

| **Aspect**                 | **TCP (Transmission Control Protocol)**                           | **UDP (User Datagram Protocol)**                                  |
|----------------------------|------------------------------------------------------------------|------------------------------------------------------------------|
| **Service Model**          | Reliable and connection-oriented                                | Unreliable and connectionless                                   |
| **Application Selection**  | Chosen by the application developer                            | Chosen by the application developer                            |
| **Terminology**            | Uses "segment" for segments                                    | Uses "datagram" for segments                                   |
| **Network Layer Protocol** | Operates on top of IP (Internet Protocol)                      | Operates on top of IP (Internet Protocol)                      |
| **Services Provided**      | Reliable data transfer, flow control, sequence numbers, acknowledgments, timers, and congestion control | Process-to-process data delivery and error checking            |
| **Reliability**            | Reliable - Ensures data delivery, integrity, and order          | Unreliable - Does not guarantee data integrity or delivery      |
| **Congestion Control**     | Regulated - Prevents excessive traffic and aims for fair sharing of network resources | Unregulated - No congestion control                            |
| **Complexity**             | Complex due to additional services and mechanisms              | Simpler and less complex                                       |
| **Key Features**           | In-order delivery, flow control, congestion control, connection setup | Unordered delivery, no flow or congestion control, no connection setup |
| **Services Not Available** | No delay or bandwidth guarantees                              | No delay or bandwidth guarantees                              |


## 3.2 Multiplexing and Demultiplexing
<p align="center">
<img width="562" alt="Screenshot 2024-12-09 at 1 37 38 AM" src="https://github.com/user-attachments/assets/187df42a-c851-4944-afed-4c5ee4a75ceb">
</p>
- The transport layer in intermediate hosts performs both demultiplexing and multiplexing.They occur based on segment, datagram header field values. Happens at all layers

**Multiplexing**
- Performed by the sender's transport layer, which combines data from multiple application processes (sockets), attaches the necessary headers (containing source and destination port numbers), and passes the segments to the network layer for transmission.
- Multiplexing involves gathering data from different sockets, encapsulating it with header information to create segments, and passing the segments to the network layer.
- Sockets have unique identifiers. Special fields in segments identify the socket for delivery.
- These fields include `source port number` and `destination port number`.
- Port numbers are 16 bit numbers, ranging from 0 to 65535. The well known port numbers (0 to 1023) are reserved for established application protocols.

**Demultiplexing**
- The job of delivering the data in a transport-layer segment to the correct socket 
- Performed by the receiver's transport layer, which reads the headers of incoming segments, identifies the destination port numbers, and delivers the data to the correct socket .
- Transport layer delivers data to an intermediary socket, not directly to a process.  
  <img width="206" alt="Screenshot 2024-12-09 at 1 49 40 AM" src="https://github.com/user-attachments/assets/9c73c4c5-e406-4c71-a38a-b041500c8925">
- Hosts uses IP addresses & port numbers to direct segment to the corresponding socket, ensuring data is delivered to the correct process.
  - UDP:  datagram has source IP address, destination IP address. delievers using destination port number (only) for demultiplexing 
  - TCP:  segment using 4-tuple: source and destination IP addresses, and port numbers

**Connectionless Multiplexing and Demultiplexing** 
1. Socket and Port Assignment :A socket is created and bound to local-host with specific port number.
 `DatagramSocket mySocket1 = new DatagramSocket(12534);`

2. Sending UDP Datagram: When creating the datagram source host must specifies `Destination IP address and Destination port number`
3. Receiving UDP Datagram: The transport layer at the receiving host inspects the `destination port number` in the UDP header then directs it to approperiate socket. **It Only uses destination port for demultiplexing**
   
   - Even if the datagrams come from different source IPs or source ports, as long as they share the same destination port, they will all be directed to the same socket on the receiving host.
   - The source port number in a UDP segment serves as part of the **"return address"**. It allows the recipient to send a response back to the sender.

     <img width="450" alt="Screenshot 2024-12-09 at 2 50 55 AM" src="https://github.com/user-attachments/assets/21b66cb4-bec0-4bc4-9e2f-1f6789007f46">

**Connection-oriented Multiplexing and Demultiplexing**
- A TCP socket is identified by the four-tuple: (`source IP address`, `source port number`, `destination IP address`, `destination port number`)
-  When a TCP segment arrives from the network to a host, the host **uses all four values to demultiplex the segment to the appropriate socket**
-  A single server can handle multiple TCP connections simultaneously; each socket identified by 4-tuple and is  associated with a different connecting client
-   Two arriving TCP segments with different source IP addresses or source port numbers will (with the exception of a TCP carrying the original connection establishment request) be directed to two different sockets.
     <img width="450" alt="Screenshot 2024-12-09 at 2 57 56 AM" src="https://github.com/user-attachments/assets/8db88fd0-bdb4-4e58-a961-2bf99a9d13cd">

## 3.3 Connectionless Transport: UDP
- UDP does multiplexing/demultiplexing, light error checking, nothing more. If the developer chooses UDP, the application is almost directly talking with IP. Note that with UDP there is no handshaking between sending and receiving transport-layer entities before sending a segment. For this reason UDP is said to be connectionless.
-  DNS is an example of an application layer protocol that typically uses UDP: there is no handshaking and when a client doesn't receive a reply either it tries sending the query to another name server or it informs the invoking application that it can't get a reply. **Why should a developer choose UDP?**
   -  **Finer application-level control over what data is sent and when**: as soon as the application passes data to UDP, UDP will package the data inside a segment and immediately pass it to the network layer. TCP's congestion control can delay the sending of the segment and will try sending the packet until this is received. In real time applications the sending rate is important, so we can trade off some data loss for some sending rate.
   -  **No connection establishement** UDP justs send data without any formal preliminaries without introducing any delay, probably the reason why DNS runs over UDP. (**No handshaking**)
   -  **No connection state** because a UDP application doesn't need to keep track of the users or to keep connections alive, it can typically support many more active clients than a TCP application
   -  **Small packet header overhead Size** TCP has 20 bytes of header overhead in every segment versus the 8 of UDP
   -  UDP is a "no frills," bare-bones transport protocol. It Provides best-effort delivery, meaning: Data may be lost during transmission and Data may arrive out of order.
- It is possible for an application developer to have reliable data transfer when using UDP. This can be done if reliability is built into the application itself (eg adding acknowledgement and retransmission mechanisms) but it is a nontrivial task and may keep the developer busy for a long time.

**Usage of UDP:**
- **Streaming Multimedia Applications**: Loss-tolerant and rate-sensitive applications such as video streaming, online gaming, and voice-over-IP (VoIP). Prioritizes speed over reliability.
- **DNS (Domain Name System)**: Quick resolution of domain names into IP addresses.
- **SNMP (Simple Network Management Protocol)**: Used for monitoring and managing devices in a network.
- **HTTP/3**: Modern web protocol designed for speed and efficiency, built on top of UDP.

**If you need reliable Transfer Over UDP:**
  - add reliability mechanisms (acknowledgments, retransmissions) at the application layer.
  - add congestion control at application layer

<img width="700" alt="Screenshot 2024-12-09 at 3 27 02 AM" src="https://github.com/user-attachments/assets/027c921d-3f3f-491a-9a14-c829bcd806a2">

### 3.3.1 UDP Segment Structure
<img width="300" alt="Screenshot 2024-12-09 at 3 28 23 AM" src="https://github.com/user-attachments/assets/9046b5e1-f380-4c65-8ec6-334a7b39ef56">

The UDP header has only four fields, each consisting of two bytes: 
 - `source port number`
 - `destination port number`
 - `checksum` (used for error detection.)
 - `length` (which specifies the number of bytes in the UDP segment, header + data)
 
This `length` field is needed since the size of the data field may differ from one UDP segment to the next.

### 3.3.2 UDP Checksum
- checksum is used to determine whether bits within the UDP segment have been altered (for example, by noise in the links or while stored in a router) as it moved from source to destination.

- Sender:
  - Treats the entire UDP segment (header + data) as a sequence of 16-bit integers.
  - Computes a checksum by performing a one’s complement sum of these integers.
  - Places the resulting checksum value in the UDP header’s checksum field.

- Receiver:
  - Computes the checksum using the same algorithm on the received segment.
  - check if computed checksum equals checksum field value
      - If equal, no errors are detected in the segment.
      - If not equal, an error (( flipped bit) is detected.
    
**Example: Adding Two 16-bit Integers**
```
1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0
1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
--------------------------------
1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 1 ( wraparound)
--------------------------------
1 0 1 1 1 0 1 1 1 0 1 1 1 1 0 0 (sum)
0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 (checksum) 
```

**Why UDP provides a checksum in the first place, as many link-layer protocols also provide error checking?**
- There is no guarantee that all the links between source and destination provide error checking.
- If segments are correctly transferred across a link, it’s possible that bit errors could be introduced when a segment is stored in a router’s memory.

End-end principle is a system design principle which states that since certain functionality must be implemented on an end-end basis: “functions placed at the lower levels may be redundant or of little value when compared to the cost of providing them at the higher level.”

## 3.4 Principles of Reliable Data Transfer
